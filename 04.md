# ４章 柔軟なインターフェイス

オブジェクトはメッセージの送信で定義されるべきである。クラスが何を「明らかにする」かが重要。
そうすることによってパブリックなインターフェイスが明らかになる。パブリックなインターフェイスは外部から依存されているものなので簡単に変更はされない。

パブリックなインターフェイスは外部のみから使われることを想定されており変更は少なくてはならないので、プライベートインターフェイスより成り立っている。
またテストで完全に文章化される。

## 旅行会社の話

旅行者`Costomer`がいて、旅行`Trip`の準備をする場合。つまりCostomerが旅行の準備をするメソッド実装するときの話。

```
Costomer >> suitable_trip(on_date, of_difficulty, need_bike) >> Trip
```

こんな状況があるとする。一見Tripが旅行の準備をするのは正しいと思うが「適切な自転車が利用可能かどうか調べる」責任があるべきがどうか。。。
　
この考え（このメッセージを送るべきだが、誰が応答するべきだろうか）がメッセージを送るためにオブジェクトが存在すると言う考え。

suitable_tripをCostomerが要求するのは正しいが、Tripに送るべきではないと言うこと。では誰に送るか？
自転車が利用可能かを教えてくれるオブジェクトはおそらく自転車`Bicycle`である。つまり

```
Costomer >> suitable_trip(on_date, of_difficulty) >> Trip
Costomer >> suitable_bicycle(trip_date, route_type) >> Bicycle
```

となる。しかしこれではダメな面もある。Tripから余計な責任は除いたもののそれがCostomerに移っただけ。Costomerが旅行の準備をするのに自転車の準備をしないといけないといった責任が増えた。

ここで自転車の準備といった責任を`Mechanic`に委託することにする。

```
Trip >> prepare_bicycle(bike) >> Mechanic
```

しかしこの状況はMechanicに自転車の準備を委託することを知っている状態である。（`prepare_bicycle`が存在する。）
ベストな方法は、相手がだれかも、何をするかの内容を知らなくても委託することができるオブジェクト。
それこそ依存オブジェクトの注入。ダックタイピング。

```
Trip >> prepare_trip(self) >> Mechanic
```

TripはMecanicに`self`を渡している。こうすることで旅行の準備に自転車の準備が必要という責任はMechanicさえ知っていれば良い。






