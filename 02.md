# ２章 単一責任のクラスを設計する

「コードの変更が簡単である」は次のように定義されるべきだ。

1. 変更は副作用をもたらさない
2. 要件の変更が小さければコードの変更も小さい
3. 既存のコードは簡単に再利用できる
4. 最も簡単な変更方法はコードの追加。しかし、追加するコードはそれ自体が変更容易である。

と言うことは以下である。

1. どんなへんこうでも変更による影響範囲が明白である。
2. 変更にかかるコストによる利益が其れ相応
3. 他の環境でも再利用可能
4. コードに変更を加える人が上記の性質を保てる

# 単一の責任になっているかの確認

## 問いただす

メソッドを質問に変えてみてしっくりくるか？

例えば、「Gearさん、あなたのギアの比を教えて」は理にかなっている。しかし、「Gearさん、あなたのギアインチを教えて」「タイヤのサイズを教えて」は完全に違う。

## クラスを１文で説明する

クラスを１文で簡単に説明してみて「それと」や「または」などの言葉が含まれていれば、余計な責任があると思われる。

Gearクラスは「自転車へのギアの影響を計算する」。これだとタイヤサイズを教えるなどはピンとこない

# 変更を受け入れるコード

データではなくて振る舞いに依存せよ。データにアクセスする方法は2つある。インスタンス変数を直接参照する方法と、アクセサメソッドで隠蔽する方法だ。
データを直接操作するのではなく、振る舞いによって操作する。

また他から渡されたデータの構造（例えば配列とかのインデックスの順序など）を知っているのはよくない。そのデータの形に依存している事になる。

## 他のデータの情報を使うなら、知っているべきはデータの構造ではなくて送るメッセージ

以下はdiamitersという直径を知るための例。もとはdataという配列を直接参照していたが、変更後はwheelオブジェクトに`tire`というメッセージを送るだけ担っている。

```ruby
class Gear
  # 以下はダメな例
  # dataとは配列
  # 配列のインデックスを知っている必要がある。
  def diamiters
    data.collect do |cell|
      cell[0] + cell[1] * 2
    end
  end
  
# 良い例
# データをオブジェクトに
  def diamiters
    wheels.collect do |w| 
      wheel.rim + (wheel.tire * 2)
    end
  end
end
```

## メソッドの責任も1つにする

改善したコードの`diamiters`メソッドでは2つの責任を持っている。wheelを一つ計算するのと、全てを返すことだ

```ruby
def diamiters
  wheels.collect{|wheel| diamiter(wheel)}
end

def diamiter(wheel)
  wheel.rim + (wheel.tire * 2)
end
```

これによる恩恵は以下である。

1. 隠された処理を分けることで、他のクラスで行うべきだったことを発見する
2. コメントが不要になる。むしろ過度なコメントがあったら別メソッドにできないか検討する。
3. 再利用が簡単

## クラスの責任を明確にする

直径(diamiter)はそもそもタイヤの話なのでWheelクラスが知っている情報であるべきだ。

```ruby
class Gear
  def initialize(wheel)
    @wheel = wheel
  end

  ...@wheel...を使った処理
end

class Wheel

  def diamiter(wheel)
    wheel.rim + (wheel.tire * 2)
  end
end

